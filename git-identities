#!/usr/bin/env python3

from pathlib import Path
from os.path import basename
from colors import Colors
import git
import configparser
import argparse

identities_file_path = str(Path.home() / '.git_identities')


# subparsers 'command' functions
def list_identities(c_args):
    identities = configparser.ConfigParser()
    identities.read(identities_file_path)
    identity_counter = 0
    for identity in identities.sections():
        if identity[:9] == 'identity.':
            identity_counter += 1
            identity_obj = identities[identity]
            line = '  '
            git_config_user = git.config_get('user', 'name')
            git_config_email = git.config_get('user', 'email')
            if identity_obj['name'] == git_config_user[0] and \
                    identity_obj['email'] == git_config_email[0]:
                line = '* '
                if git_config_user[1] or git_config_email[1]:
                    line += Colors.yellow
                else:
                    line += Colors.green
            line += identity[9:] + Colors.default
            if c_args.verbose:
                line += " (%s <%s>)" % (identity_obj['name'], identity_obj['email'])
            print(line)
    if identity_counter == 0:
        print(Colors.red + 'There are no saved identities.' + Colors.default)
        print('\nUse\n   %s add ...\nto add a new identity.' % basename(__file__))
    return 0


def show_identity(c_args):
    git_config_user = git.config_get('user', 'name')
    git_config_email = git.config_get('user', 'email')
    identities = configparser.ConfigParser()
    identities.read(identities_file_path)
    identity = c_args.identity
    if identity is None:
        for identity_entry in identities.sections():
            identity_entry_obj = identities[identity_entry]
            if identity_entry_obj['name'] == git_config_user[0] and \
                    identity_entry_obj['email'] == git_config_email[0]:
                identity = identity_entry[9:]
                break
    if identity is None:
        print('[?] %s <%s>' % (git_config_user[0], git_config_email[0]))
        print(Colors.red +
              'The identity in the current context is not known to %s.' % basename(__file__) +
              Colors.default)
        print('You can add the current identity with\n   %s add --current' % basename(__file__))
        return

    identity_obj = identities['identity.' + identity]
    print('[%s] %s <%s>' % (identity, identity_obj['name'], identity_obj['email']))
    if identity_obj['name'] == git_config_user[0] and \
            identity_obj['email'] == git_config_email[0]:
        line = 'This is the ' + Colors.green + 'default' + Colors.default + ' identity in the current context.'
        if git_config_user[1] or git_config_email[1]:
            line += '\nIt is set ' + Colors.yellow + 'locally' + Colors.default + ' in the current repository.'
        else:
            line += '\nIt is set globally.'
        print(line)
    return 0


def add_identity(c_args):
    if not c_args.identity.isidentifier():
        print(Colors.red + 'The specified identity ID is not a valid identifier.' + Colors.default)
        return 1

    name = None
    email = None
    if c_args.current:
        git_config_user = git.config_get('user', 'name')
        git_config_email = git.config_get('user', 'email')
        name = git_config_user[0]
        email = git_config_email[0]
    else:
        name = c_args.name
        email = c_args.email
        if name is None or email is None:
            print(Colors.red + 'error: the following arguments are required: name, email or -c' + Colors.default)
            return 2

    identities = configparser.ConfigParser()
    identities.read(identities_file_path)
    if not c_args.force and identities.has_section('identity.' + c_args.identity):
        print(Colors.red + 'The specified identity ID already exists.' + Colors.default)
        print('To replace the existing identity, specify --force.')
        return 3

    identities['identity.' + c_args.identity] = {
        'name': name,
        'email': email
    }

    with open(identities_file_path, 'w') as identities_file:
        identities.write(identities_file)
    return 0


def remove_identity(c_args):
    identities = configparser.ConfigParser()
    identities.read(identities_file_path)
    if not identities.has_section('identity.' + c_args.identity):
        print(Colors.red + "The specified identity ID doesn't exist." + Colors.default)
        return 1

    identities.remove_section('identity.' + c_args.identity)
    with open(identities_file_path, 'w') as identities_file:
        identities.write(identities_file)
    return 0


def apply_identity(c_args):
    identities = configparser.ConfigParser()
    identities.read(identities_file_path)
    if not identities.has_section('identity.' + c_args.identity):
        print(Colors.red + "The specified identity ID doesn't exist." + Colors.default)
        return 1

    if not c_args.local:
        git_config_user = git.config_get('user', 'name')
        git_config_email = git.config_get('user', 'email')
        if git_config_user[1] or git_config_email[1]:
            print(Colors.yellow + 'Warning:' + Colors.default +
                  ' the current repo has a local identity config and will not use the new value.')

    identity_obj = identities['identity.' + c_args.identity]
    result_n = git.config_set('user', 'name', identity_obj['name'], local=c_args.local)
    result_e = git.config_set('user', 'email', identity_obj['email'], local=c_args.local)
    if not result_e and not result_n:
        return 5
    elif not result_e:  # and resultN
        return 2
    elif not result_n:  # and resultE
        return 3
    else:  # both True
        return 0


def unset_identity(c_args):
    result_n = git.config_unset('user', 'name')
    result_e = git.config_unset('user', 'email')
    if not result_e and not result_n:
        return 5
    elif not result_e:  # and resultN
        return 2
    elif not result_n:  # and resultE
        return 3
    else:  # both True
        return 0


# --- execution begins here ---

parser = argparse.ArgumentParser(epilog='Manage identities for Git commits.')
subparsers = parser.add_subparsers(metavar='command',
                                   title='command',
                                   description='the command to be executed.',
                                   dest='command')
subparsers.required = True
parser_list = subparsers.add_parser('list',
                                    help='list all known identities',
                                    aliases=['ls'])
parser_list.set_defaults(func=list_identities)
parser_list.add_argument('-v', '--verbose',
                         action='store_true',
                         help='print all details about every identity')

parser_show = subparsers.add_parser('show',
                                    help='show details about the given identity',)
parser_show.set_defaults(func=show_identity)
parser_show.add_argument('identity', nargs='?', help='the identity to show details about', default=None)

parser_add = subparsers.add_parser('add',
                                   help='add a new identity')
parser_add.set_defaults(func=add_identity)
parser_add.add_argument('-c', '--current',
                        action='store_true',
                        help="add the identity of the current context, either from the current repo's .git/config or "
                             "the global gitconfig")
parser_add.add_argument('identity', help='a unique ID for the new identity')
parser_add.add_argument('name',
                        help='the full user name, to use for git-config user.name; required if not specifying -c',
                        nargs='?',
                        default=None)
parser_add.add_argument('email',
                        help='the email address, to use for git-config user.name; required if not specifying -c',
                        nargs='?',
                        default=None)
parser_add.add_argument('-f', '--force',
                        action='store_true',
                        help="overwrite any already existing identity with the given ID")

parser_remove = subparsers.add_parser('remove',
                                      help='remove a known identity')
parser_remove.set_defaults(func=remove_identity)
parser_remove.add_argument('identity', help='the unique ID of the identity to remove')

parser_apply = subparsers.add_parser('apply',
                                     help='set the config to use the specified known identity')
parser_apply.set_defaults(func=apply_identity)
parser_apply.add_argument('identity', help='the unique ID of the identity to apply')
parser_apply.add_argument('--global',
                          dest='local',
                          action='store_false',
                          help="apply the identity globally for all non-configured projects")
parser_apply.add_argument('--local',
                          dest='local',
                          action='store_true',
                          required=False,
                          help="apply the identity locally for the current repo (default)")

parser_use_global = subparsers.add_parser('use-global',
                                          help='remove any local identity config to reset to the global identity')
parser_use_global.set_defaults(func=unset_identity)

args = parser.parse_args()
result = args.func(args)

exit(result)
